signature Pretty =
sig
  type t
  type line = int * string

  val pretty : int option -> t -> string
  (* The flattening never contains line breaks *)
  val flatten : t -> t
  val fold : (line * 'a -> 'a) -> 'a -> int option -> t -> 'a
  val linearize : int option -> t -> line list

  val empty : t (* empty = txt "" *)
  val txt : string -> t


  (* New line and indent or a space depending on grouping. *)
  val ln : t

  (* New line and indent or nothing depending on grouping. *)
  val brk : t


  (* Add a number of columns to the indentation level. *)
  val nest : int -> t -> t

  (* Alternative outputs: The narrow alternative is just the given document. The
   * wide one is generated by treating new lines and line breaks as described
   * above and for each choice in the document taking the wide one. *)
  val group : t -> t

  (* Alternative outputs: The first component is a wide variant, the second is a
   * narrow one.
   * Note: The wide variant is flattened, so it will not contain line breaks. *)
  val choice : t * t -> t

  (* Primarily useful for specifying the narrow alternative to choice; If the
   * wide variant fits, the narrow one is never evaluated. *)
  val delay : t Lazy.thunk -> t


  (* Takes a function that given the number of characters printed so far
   * generates a document.
   *)
  val printed : (int -> t) -> t

  (* Takes a function that given the number of rows and columns (in the current
   * line) printed so far generates a document.
   *)
  val position : ({row: int, column: int} -> t) -> t

  (* Takes a function that given the current nesting level generates a document.
   *)
  val nesting : (int -> t) -> t

  (* Takes a function that given the desired maximal printing width generates a
   * document
   *)
  val max : (int option -> t) -> t

  val ^^ : t * t -> t (* Join horizontally. *)
end
